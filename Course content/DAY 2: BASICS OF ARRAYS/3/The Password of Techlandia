SOLUTION ==>

#include <iostream>
#include <vector>
#include <unordered_map> 
#include <climits>
using namespace std;

void validate_password(const std::vector<int>& password, std::string& result, int& most_frequent_element) {
   unordered_map<int, int> freq;
    
    // Count frequency of each element
    for (int num : password) {
        freq[num]++;
    }

    bool allEven = true;
    bool hasExactlyTwo = false;
    int maxFreq = 0;
    most_frequent_element = INT_MAX;

    // Check conditions and find most frequent element
    for (auto& pair : freq) {
        int num = pair.first;
        int count = pair.second;

        // Condition checks
        if (count % 2 != 0)
            allEven = false;
        if (count == 2)
            hasExactlyTwo = true;

        // Track most frequent (choose smaller if same frequency)
        if (count > maxFreq || (count == maxFreq && num < most_frequent_element)) {
            maxFreq = count;
            most_frequent_element = num;
        }
    }

    // Determine validity
    if (allEven && hasExactlyTwo)
        result = "VALID";
    else
        result = "INVALID";
}

int main() {
    int N;
    std::cin >> N;
    std::vector<int> password(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> password[i];
    }
    std::string validation_result;
    int most_frequent_element;
    validate_password(password, validation_result, most_frequent_element);
    std::cout << validation_result << '\n';
    std::cout << most_frequent_element << '\n';
    return 0;
}
