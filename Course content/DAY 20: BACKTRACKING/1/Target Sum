SOLUTION ===>>>

#include <iostream>
#include <vector>
#include <unordered_map>
#include <string>
using namespace std;

// Memoization key
string key(int index, int sum) {
    return to_string(index) + "," + to_string(sum);
}

int dfs(const vector<int>& nums, int index, int curr_sum, int target, unordered_map<string,int>& memo) {
    if (index == nums.size()) {
        return curr_sum == target ? 1 : 0;
    }
    
    string k = key(index, curr_sum);
    if (memo.count(k)) return memo[k];
    
    // Choose +nums[index]
    int add = dfs(nums, index + 1, curr_sum + nums[index], target, memo);
    // Choose -nums[index]
    int sub = dfs(nums, index + 1, curr_sum - nums[index], target, memo);
    
    return memo[k] = add + sub;
}

int user_logic(const std::vector<int>& nums, int target) {
    unordered_map<string,int> memo;
    return dfs(nums, 0, 0, target, memo);
}

int main() {
    int n, target;
    std::cin >> n;
    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }
    std::cin >> target;
    int ways = user_logic(nums, target);
    std::cout << ways << std::endl;
    return 0;
}
