SOLUTION ==>>

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int k) : key(k), left(nullptr), right(nullptr) {}
};

// Helper function to build BST from postorder
Node* buildBST(vector<int>& postorder, int start, int end) {
    if (start > end) return nullptr;

    // Last element in postorder is the root
    int rootVal = postorder[end];
    Node* root = new Node(rootVal);

    // Find the first element greater than rootVal from the left
    int idx = start;
    while (idx <= end - 1 && postorder[idx] < rootVal) {
        idx++;
    }

    // Left subtree: start to idx-1
    // Right subtree: idx to end-1
    root->left = buildBST(postorder, start, idx - 1);
    root->right = buildBST(postorder, idx, end - 1);

    return root;
}

vector<int> user_logic(vector<int>& postorder) {
    int n = postorder.size();
    Node* root = buildBST(postorder, 0, n - 1);

    // Level order traversal to collect second-last row
    vector<int> secondLastRow;
    if (!root) return secondLastRow;

    queue<Node*> q;
    q.push(root);

    vector<int> prevLevel; // keep track of previous level
    while (!q.empty()) {
        int sz = q.size();
        vector<int> currLevel;

        for (int i = 0; i < sz; i++) {
            Node* node = q.front();
            q.pop();
            currLevel.push_back(node->key);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        if (!q.empty()) {
            // If not last level, store as secondLastRow candidate
            secondLastRow = currLevel;
        }
    }

    return secondLastRow;
}

int main() {
    int n;
    cin >> n;
    vector<int> postorder(n);
    for (int i = 0; i < n; i++) {
        cin >> postorder[i];
    }
    vector<int> result = user_logic(postorder);
    for (int x : result) {
        cout << x << " ";
    }
    return 0;
}
